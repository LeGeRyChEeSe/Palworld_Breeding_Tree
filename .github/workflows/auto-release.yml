name: Auto Release

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run (no release created)'
        required: false
        default: false
        type: boolean

jobs:
  check-version-and-release:
    runs-on: windows-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
    
    - name: Extract version
      id: extract_version
      run: |
        $version = python core/scripts/get_version.py
        if ($LASTEXITCODE -ne 0) {
          Write-Error "Failed to extract version"
          exit 1
        }
        Write-Output "VERSION=$version" >> $env:GITHUB_OUTPUT
        Write-Output "Current version: $version"
      shell: powershell
    
    - name: Check if tag exists
      id: check_tag
      run: |
        $version = "${{ steps.extract_version.outputs.VERSION }}"
        $tagExists = git tag -l "v$version"
        if ($tagExists) {
          Write-Output "TAG_EXISTS=true" >> $env:GITHUB_OUTPUT
          Write-Output "Tag v$version already exists, skipping release"
        } else {
          Write-Output "TAG_EXISTS=false" >> $env:GITHUB_OUTPUT
          Write-Output "Tag v$version does not exist, proceeding with release"
        }
      shell: powershell
    
    - name: Get latest release version
      id: get_latest_version
      if: steps.check_tag.outputs.TAG_EXISTS == 'false'
      run: |
        # Check if any tags exist
        $allTags = git tag -l
        if ($allTags -and $allTags.Count -gt 0) {
          try {
            $latestTag = git describe --tags --abbrev=0
            if ($LASTEXITCODE -eq 0 -and $latestTag) {
              $latestVersion = $latestTag -replace '^v', ''
              Write-Output "LATEST_VERSION=$latestVersion" >> $env:GITHUB_OUTPUT
              Write-Output "Latest version: $latestVersion"
            } else {
              Write-Output "LATEST_VERSION=" >> $env:GITHUB_OUTPUT
              Write-Output "No valid previous tags found"
            }
          } catch {
            Write-Output "LATEST_VERSION=" >> $env:GITHUB_OUTPUT
            Write-Output "Error getting latest tag: $_"
          }
        } else {
          Write-Output "LATEST_VERSION=" >> $env:GITHUB_OUTPUT
          Write-Output "No previous tags found - this will be the first release"
        }
      shell: powershell
    
    - name: Compare versions
      id: compare_versions
      if: steps.check_tag.outputs.TAG_EXISTS == 'false'
      run: |
        $currentVersion = "${{ steps.extract_version.outputs.VERSION }}"
        $latestVersion = "${{ steps.get_latest_version.outputs.LATEST_VERSION }}"
        
        if (-not $latestVersion) {
          Write-Output "SHOULD_RELEASE=true" >> $env:GITHUB_OUTPUT
          Write-Output "No previous version found, creating first release"
          exit 0
        }
        
        # Simple version comparison (assumes semantic versioning)
        $current = [System.Version]::Parse($currentVersion)
        $latest = [System.Version]::Parse($latestVersion)
        
        if ($current -gt $latest) {
          Write-Output "SHOULD_RELEASE=true" >> $env:GITHUB_OUTPUT
          Write-Output "Version $currentVersion is greater than $latestVersion, proceeding with release"
        } else {
          Write-Output "SHOULD_RELEASE=false" >> $env:GITHUB_OUTPUT
          Write-Output "Version $currentVersion is not greater than $latestVersion, skipping release"
        }
      shell: powershell
    
    - name: Build executable
      id: build
      if: steps.compare_versions.outputs.SHOULD_RELEASE == 'true' && steps.check_tag.outputs.TAG_EXISTS == 'false'
      run: |
        Write-Output "Building executable..."
        .\build.bat
        if ($LASTEXITCODE -ne 0) {
          Write-Error "Build failed"
          exit 1
        }
        
        $version = "${{ steps.extract_version.outputs.VERSION }}"
        $exePath = "Build\Palworld_Breeding_Tree-$version-Windows.exe"
        
        if (Test-Path $exePath) {
          # Convert Windows path to Unix path for GitHub Actions
          $unixPath = $exePath.Replace('\', '/')
          Write-Output "EXE_PATH=$unixPath" >> $env:GITHUB_OUTPUT
          Write-Output "Build successful: $exePath (GitHub path: $unixPath)"
        } else {
          Write-Error "Expected executable not found: $exePath"
          exit 1
        }
      shell: powershell
    
    - name: Extract changelog
      id: changelog
      if: steps.compare_versions.outputs.SHOULD_RELEASE == 'true' && steps.check_tag.outputs.TAG_EXISTS == 'false'
      run: |
        $version = "${{ steps.extract_version.outputs.VERSION }}"
        $changelogPath = "CHANGELOG.md"
        
        if (Test-Path $changelogPath) {
          # Read with UTF-8 encoding to properly handle emojis
          $content = Get-Content $changelogPath -Raw -Encoding UTF8
          # Extract changelog section for current version only
          # Pattern matches ## [version] or ## version and captures content until next version or end
          $escapedVersion = $version.Replace('.', '\.')
          $pattern = "(?s)^## \[?v?$escapedVersion\]?.*?(?=^## \[?v?[\d\.]+\]?|\z)"
          $match = [regex]::Match($content, $pattern, [System.Text.RegularExpressions.RegexOptions]::Multiline)
          
          if ($match.Success) {
            $changelog = $match.Value.Trim()
            # Remove the version header line and any date information
            $changelog = $changelog -replace "^## \[?v?$escapedVersion\]?[^\r\n]*(\r?\n)?", ""
            $changelog = $changelog.Trim()
            
            # Ensure changelog is not empty
            if ([string]::IsNullOrWhiteSpace($changelog)) {
              $changelog = "Release version $version"
            }
          } else {
            Write-Warning "Could not find changelog section for version $version"
            $changelog = "Release version $version"
          }
        } else {
          Write-Warning "CHANGELOG.md not found"
          $changelog = "Release version $version"
        }
        
        # Handle multi-line content for GitHub Actions with UTF-8 encoding
        $delimiter = "EOF_CHANGELOG_$(Get-Random)"
        # Use UTF-8 encoding for output to preserve emojis
        [Console]::OutputEncoding = [System.Text.Encoding]::UTF8
        Write-Output "CHANGELOG<<$delimiter" >> $env:GITHUB_OUTPUT
        Write-Output $changelog >> $env:GITHUB_OUTPUT
        Write-Output $delimiter >> $env:GITHUB_OUTPUT
        
        Write-Output "Changelog extracted for version $version"
        Write-Output "First 200 chars of changelog: $($changelog.Substring(0, [Math]::Min(200, $changelog.Length)))"
      shell: powershell
    
    - name: Create Release (Dry Run)
      if: steps.compare_versions.outputs.SHOULD_RELEASE == 'true' && steps.check_tag.outputs.TAG_EXISTS == 'false' && github.event.inputs.dry_run == 'true'
      run: |
        $version = "${{ steps.extract_version.outputs.VERSION }}"
        $exePath = "${{ steps.build.outputs.EXE_PATH }}"
        
        # Set UTF-8 encoding for console output
        [Console]::OutputEncoding = [System.Text.Encoding]::UTF8
        
        Write-Output "=== DRY RUN: Release Preview ==="
        Write-Output "Tag: v$version"
        Write-Output "Name: Palworld Breeding Tree v$version"
        Write-Output "Executable (Unix path): $exePath"
        
        # Convert to Windows path for local verification
        $winPath = $exePath.Replace('/', '\')
        if (Test-Path $winPath) {
          $fileSize = (Get-Item $winPath).Length
          Write-Output "Executable size: $([math]::Round($fileSize/1MB, 2)) MB"
          Write-Output "Local path: $winPath"
        } else {
          Write-Warning "Executable not found at: $winPath"
        }
        
        Write-Output ""
        Write-Output "=== Changelog Preview ==="
        Write-Output "${{ steps.changelog.outputs.CHANGELOG }}"
      shell: powershell
    
    - name: Verify executable before release
      if: steps.compare_versions.outputs.SHOULD_RELEASE == 'true' && steps.check_tag.outputs.TAG_EXISTS == 'false' && github.event.inputs.dry_run != 'true'
      run: |
        $unixPath = "${{ steps.build.outputs.EXE_PATH }}"
        # Convert back to Windows path for local verification
        $exePath = $unixPath.Replace('/', '\')
        
        if (-not (Test-Path $exePath)) {
          Write-Error "Executable not found at: $exePath (Unix path: $unixPath)"
          exit 1
        }
        $fileSize = (Get-Item $exePath).Length
        Write-Output "Executable found: $exePath (Size: $([math]::Round($fileSize/1MB, 2)) MB)"
        Write-Output "Unix path for release: $unixPath"
      shell: powershell
    
    - name: Debug file listing
      if: steps.compare_versions.outputs.SHOULD_RELEASE == 'true' && steps.check_tag.outputs.TAG_EXISTS == 'false' && github.event.inputs.dry_run != 'true'
      run: |
        Write-Output "=== Directory Listing ==="
        Write-Output "Current directory:"
        Get-Location
        Write-Output "Build directory contents:"
        if (Test-Path "Build") {
          Get-ChildItem "Build" | ForEach-Object { Write-Output "  $($_.Name) ($($_.Length) bytes)" }
        } else {
          Write-Output "  Build directory not found"
        }
        
        $unixPath = "${{ steps.build.outputs.EXE_PATH }}"
        Write-Output "File to upload: $unixPath"
        Write-Output "File exists check: $(Test-Path $unixPath.Replace('/', '\'))"
      shell: powershell
    
    - name: Create Release
      if: steps.compare_versions.outputs.SHOULD_RELEASE == 'true' && steps.check_tag.outputs.TAG_EXISTS == 'false' && github.event.inputs.dry_run != 'true'
      uses: softprops/action-gh-release@v1
      with:
        tag_name: "v${{ steps.extract_version.outputs.VERSION }}"
        name: "Palworld Breeding Tree v${{ steps.extract_version.outputs.VERSION }}"
        body: ${{ steps.changelog.outputs.CHANGELOG }}
        files: ${{ steps.build.outputs.EXE_PATH }}
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Summary
      if: always()
      run: |
        # Set UTF-8 encoding for console output
        [Console]::OutputEncoding = [System.Text.Encoding]::UTF8
        
        $version = "${{ steps.extract_version.outputs.VERSION }}"
        $tagExists = "${{ steps.check_tag.outputs.TAG_EXISTS }}"
        $shouldRelease = "${{ steps.compare_versions.outputs.SHOULD_RELEASE }}"
        $isDryRun = "${{ github.event.inputs.dry_run }}"
        
        Write-Output "=== Auto-Release Summary ==="
        Write-Output "Version: $version"
        Write-Output "Tag exists: $tagExists"
        Write-Output "Should release: $shouldRelease"
        Write-Output "Dry run: $isDryRun"
        
        if ($tagExists -eq "true") {
          Write-Output "Result: Skipped - Tag already exists"
        } elseif ($shouldRelease -eq "false") {
          Write-Output "Result: Skipped - Version not greater than latest"
        } elseif ($isDryRun -eq "true") {
          Write-Output "Result: Dry run completed successfully"
        } else {
          Write-Output "Result: Release created successfully"
          $exePath = "${{ steps.build.outputs.EXE_PATH }}"
          if ($exePath) {
            Write-Output "Executable included: $exePath"
          }
        }
      shell: powershell